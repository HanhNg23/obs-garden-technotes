---
{"dg-publish":true,"permalink":"/fpt-study-take-notes/fall-2023-semester-5/prn-211/1-tien-bai-hoc-tu-java-sang-dot-net/"}
---

# Tiá»n BÃ i Há»c - Tá»« Java Sang Dot Net

---

### 1. CÆ¡ cháº¿ biÃªn dá»‹ch cá»§a Java
![](https://i.imgur.com/qifcln2.png)

1. <span style="color:#d4a216">**Java is an Platform-Independent**</span>
	- Java - a platform-independent programming language, does not work on the one-step compilation, instead, involves 2 STEPS execution:
		- First, through an OS - independent compiler
		- Second, in a JVM - Java Virtual Machine - which is custom-built for every operating system (JVM ) to run Java applications
2. <span style="color:#d4a216">**The two principle stages**</span>
	<span style="color:#6a5858">*The two principle stages for compilation and execution Java programming*</span> 
	1. <span style="color:#00b0f0">**Principle 1: Compilation**</span>
		- The source ".java" file is passed through the compiler named is "Javac"
		-> compiler encodes the source code into a machine-independent encoding - known as BYTECODE. 
		-> save into ".class" file - the content of each class contained in the source file is stored in a separate ".class" files
	2. <span style="color:#00b0f0">**Principle 2: Execution**</span>
		- The ".class" file generated by the compiler are independent of the machine or the OS --> allow them to be run on any system
		-> then the main class file (the class contained the method main) passed to the JVM --> *GOES THROUGH 3 MAIN STAGES BEFORE THE FINAL MACHINE CODE IS EXECUTED*
		
		![](https://i.imgur.com/Zoeq5m1.png)
		
		---
		1. <span style="color:#00b050">**Main stage 1: Class Loader**</span> 
			- Class loaders - responsible for loading Java Classes dynamically to the JVM during run time.
			*(--> JVM does'n need to know about the underlying file // file systems in order to run Java Programs thanks to class loader)*
			- <span style="color:#9a7db0">*ğŸ”° **Note**, not all Java clasess are loaded into memory all at once --> but rather when they're required by an application --> CLASS LOADER RESPONSIBLE TO FIND THE CLASSES AND LOAD THEM TO MEMORY*</span>.
		
			<span style="color:#d4a216">=> In this circumstance, main class is load into the memory,Â other classes referenced in the program are loaded through the class loader</span>. 

		2. <span style="color:#00b050">**Main stage 2: Bytecode Verifier**</span> 
			- After the bytecode of a class is loaded by the class loader -> it has to be inspected by the bytecode verifier - Play the role to *CHECK THAT THE INSTRUCTIONS DO NOT PERFORMING DAMAGING ACTIONS*. 
			- The following are some of the checks carried out: 
			![](https://i.imgur.com/A1Z38aD.png)
		3. <span style="color:#00b050">**Main stage 3: Just In Time Compiler**</span>
			- JVM CONVERT THE LOADED BYTECODE INTO MACHINE CODE FOR EXEUCTION ON OS WITH THE HELP OF JIT --> this process is called INTERPRETER
			
			> [!NOTE]
		   > CÃ¡c ngÃ´n ngá»¯ nhÆ°Â **C**Â hayÂ **C#**Â Ä‘Æ°á»£c trá»±c tiáº¿p biÃªn dá»‹ch (compile) ra mÃ£ mÃ¡y nÃªn khi thá»±c thi sáº½ nhanh hÆ¡n do khÃ´ng tá»‘n cÃ´ng chuyá»ƒn Ä‘á»•i (interpret) tá»«Â **bytecode**Â sangÂ **native code**Â nhÆ° Java. Do Ä‘Ã³, vá»›iÂ **compiled language**, má»—i khi cháº¡y trÃªn OS khÃ¡c nhau cáº§n compile láº¡i code Ä‘á»ƒ phÃ¹ há»£p vá»›i OS Ä‘Ã³, khÃ´ng cÃ³Â **WORA**Â nhÆ° Java, bÃ¹ láº¡i tá»‘c Ä‘á»™ thá»±c thi nhanh hÆ¡n.
		   
           > [!WARNING]- WHY JIT IS THE HEART OF JVM
           > ğŸ¤¨ Problem: The way of converting bytecode to native machine language for execution has a HUGE IMPACT ON ITS SPEED of it.
           > 
           > 
           > ğŸ’ Why:
           > 	- Bytecodes have to be interpreted or compiled to proper machine instructions depending on the instruction set architecture. 
           > 	- Moreover, these can be directly executed if the instruction architecture is bytecode based.
           > 	==> So **Interpreting the bytecode affects the speed of execution**
           > 	
           > ğŸ’â€â™€ï¸ Resolve:
           > 	- In order TO IMPROVE PERFORMANCE, JIT COMPILER INTERACT WITH THE JVM AT RUN TIME & COMPILE SUITABLE BYTECODE SEQUENCE into native machine code.
           > 	
           > 	*<span style="font-style:italic; color:#9a7db0">**JVM**Â sáº½ monitor xem Ä‘oáº¡n code nÃ o Ä‘Æ°á»£c thá»±c thi nhiá»u láº§n. Äoáº¡n code Ä‘Ã³ cÃ³ thá»ƒ lÃ  method, má»™t pháº§n cá»§a method hoáº·c má»™t vÃ²ng láº·p (loop). Sau khi tÃ¬m Ä‘Æ°á»£cÂ **block of code**Â Ä‘Ã³, thay vÃ¬ má»—i láº§n thá»±c thi pháº£iÂ **interpret**Â sangÂ **machine code**Â thÃ¬ nÃ³ Ä‘Æ°á»£cÂ **compile**Â sangÂ **machine code**Â luÃ´n cho nhanh. Táº¥t nhiÃªn sau khiÂ **compile**Â pháº£i cÃ³ nÆ¡i lÆ°u trá»¯ láº¡iÂ **native code**Â Ä‘Ã³, lÃ Â **code cache**.</span>*
           > 	<span style="color:#9a7db0">â¡ï¸ NhÆ° váº­y, táº¡i má»™t thá»i Ä‘iá»ƒm, má»™t vÃ i pháº§n cá»§a chÆ°Æ¡ng trÃ¬nh sáº½ khÃ´ng cháº¡y trong tráº¡ng thÃ¡iÂ **interpretive**Â ná»¯a mÃ  lÃ  thá»±c thi luÃ´nÂ **native code**.</span>
           > 	*<span style="font-style:italic; color:#9a7db0">Viá»‡cÂ **interpret**Â tá»«Â **bytecode**Â sangÂ **native code**Â hay quyáº¿t Ä‘á»‹nhÂ **compile**Â vÃ  lÆ°u trá»¯ láº¡iÂ **native code**Â Ä‘Ã³ hay khÃ´ng lÃ  nhiá»‡m vá»¥ cá»§aÂ **Just-in-time Compiler**, ngáº¯n gá»n hÆ¡n lÃ Â **JIT Compiler**.</span>*	
		
			<span style="color:#d4a216">==> While using a JIT compiler, the hardware is able to execute the native code  as opposed to having the JVM interpret the same sequence of bytecode repeatedly and incurring overhead for the translation process. JIT leads to performance gains in the execution speed, unless the compiled methods are executed less frequently.</span>
			<p style="text-align:center;">
		   <img src="https://media.geeksforgeeks.org/wp-content/uploads/java.jpg"/>
		   </p>

ğŸ <span style="color:#00b050">**Reference:**</span> 
	- [WORA, JIT Compiler vÃ  -XX:+PrintCompilation](https://viblo.asia/p/001-wora-jit-compiler-va-xxprintcompilation-gDVK2O3nZLj)
	- [Compilation and Execution of a Java Program](https://www.geeksforgeeks.org/compilation-execution-java-program/)
	- [How JVM Works â€“ JVM Architecture?](https://www.geeksforgeeks.org/jvm-works-jvm-architecture/)
> [!SUMMARIZE]- Summary
> file java -- sang javac -- compile -> bytecode lÆ°u trong file class (Ä‘Ã¢y Ä‘c gá»i lÃ  Bytecode nhÆ°ng ko hoÃ n chá»‰nh so vá»›i viá»‡c biÃªn dá»‹ch file C compile trá»±c tiáº¿p ra Assembly Lang) - cháº¡y vá»›i mÃ¡y áº£o JAVA - JVM (JVM work with multiple OS platform) theo chá»‰ thá»‹ cá»§a JRE
> ![](https://i.imgur.com/6RPDXCb.png)
> ![](https://i.imgur.com/rzRoNDW.png)
	

### 2. KhÃ¡i niá»‡m JDK, JRE, JVM
> - JVM lÃ  thÃ nh pháº§n ná»n táº£ng Java thá»±c thi cÃ¡c chÆ°Æ¡ng trÃ¬nh cá»§a báº¡n.
> - JRE khá»Ÿi táº¡o JVM vÃ  Ä‘áº£m báº£o cÃ¡c phá»¥ thuá»™c cÃ³ sáºµn cho cÃ¡c chÆ°Æ¡ng trÃ¬nh cá»§a báº¡n.
> - JDK cho phÃ©p báº¡n táº¡o cÃ¡c chÆ°Æ¡ng trÃ¬nh Java cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c thi vÃ  cháº¡y bá»Ÿi JVM vÃ  JRE.

![](https://i.imgur.com/vFf5XJp.png)
![](https://i.imgur.com/ZvOHqPA.png)


ğŸ <span style="color:#00b050">**Reference:**</span>  
- [DIFFERENCES BETWEEN JDK, JRE AND JVM](https://prutor.ai/differences-between-jdk-jre-and-jvm/)
- [JVM, JRE vÃ  JDK](https://howkteam.vn/course/lap-trinh-java-co-ban-den-huong-doi-tuong/cai-dat-moi-truong-java-3834)
- [JRE in Java - GeeksforGeeks](https://www.geeksforgeeks.org/jre-in-java/)












