---
{"dg-publish":true,"permalink":"/fpt-study-take-notes/fall-2023-semester-5/prn-211/1-tien-bai-hoc-tu-java-sang-dot-net/"}
---

# Tiền Bài Học - Từ Java Sang Dot Net

---

### 1. Cơ chế biên dịch của Java
![](https://i.imgur.com/qifcln2.png)

1. <span style="color:#d4a216">**Java is an Platform-Independent**</span>
	- Java - a platform-independent programming language, does not work on the one-step compilation, instead, involves 2 STEPS execution:
		- First, through an OS - independent compiler
		- Second, in a JVM - Java Virtual Machine - which is custom-built for every operating system (JVM ) to run Java applications
2. <span style="color:#d4a216">**The two principle stages**</span>
	<span style="color:#6a5858">*The two principle stages for compilation and execution Java programming*</span> 
	1. <span style="color:#00b0f0">**Principle 1: Compilation**</span>
		- The source ".java" file is passed through the compiler named is "Javac"
		-> compiler encodes the source code into a machine-independent encoding - known as BYTECODE. 
		-> save into ".class" file - the content of each class contained in the source file is stored in a separate ".class" files
	2. <span style="color:#00b0f0">**Principle 2: Execution**</span>
		- The ".class" file generated by the compiler are independent of the machine or the OS --> allow them to be run on any system
		-> then the main class file (the class contained the method main) passed to the JVM --> *GOES THROUGH 3 MAIN STAGES BEFORE THE FINAL MACHINE CODE IS EXECUTED*
		
		![](https://i.imgur.com/Zoeq5m1.png)
		
		---
		1. <span style="color:#00b050">**Main stage 1: Class Loader**</span> 
			- Class loaders - responsible for loading Java Classes dynamically to the JVM during run time.
			*(--> JVM does'n need to know about the underlying file // file systems in order to run Java Programs thanks to class loader)*
			- <span style="color:#9a7db0">*🔰 **Note**, not all Java clasess are loaded into memory all at once --> but rather when they're required by an application --> CLASS LOADER RESPONSIBLE TO FIND THE CLASSES AND LOAD THEM TO MEMORY*</span>.
		
			<span style="color:#d4a216">=> In this circumstance, main class is load into the memory, other classes referenced in the program are loaded through the class loader</span>. 

		2. <span style="color:#00b050">**Main stage 2: Bytecode Verifier**</span> 
			- After the bytecode of a class is loaded by the class loader -> it has to be inspected by the bytecode verifier - Play the role to *CHECK THAT THE INSTRUCTIONS DO NOT PERFORMING DAMAGING ACTIONS*. 
			- The following are some of the checks carried out: 
			![](https://i.imgur.com/A1Z38aD.png)
		3. <span style="color:#00b050">**Main stage 3: Just In Time Compiler**</span>
			- JVM CONVERT THE LOADED BYTECODE INTO MACHINE CODE FOR EXEUCTION ON OS WITH THE HELP OF JIT --> this process is called INTERPRETER
			
			> [!NOTE]
		   > Các ngôn ngữ như **C** hay **C#** được trực tiếp biên dịch (compile) ra mã máy nên khi thực thi sẽ nhanh hơn do không tốn công chuyển đổi (interpret) từ **bytecode** sang **native code** như Java. Do đó, với **compiled language**, mỗi khi chạy trên OS khác nhau cần compile lại code để phù hợp với OS đó, không có **WORA** như Java, bù lại tốc độ thực thi nhanh hơn.
		   
           > [!WARNING]- WHY JIT IS THE HEART OF JVM
           > 🤨 Problem: The way of converting bytecode to native machine language for execution has a HUGE IMPACT ON ITS SPEED of it.
           > 
           > 
           > 💁 Why:
           > 	- Bytecodes have to be interpreted or compiled to proper machine instructions depending on the instruction set architecture. 
           > 	- Moreover, these can be directly executed if the instruction architecture is bytecode based.
           > 	==> So **Interpreting the bytecode affects the speed of execution**
           > 	
           > 💁‍♀️ Resolve:
           > 	- In order TO IMPROVE PERFORMANCE, JIT COMPILER INTERACT WITH THE JVM AT RUN TIME & COMPILE SUITABLE BYTECODE SEQUENCE into native machine code.
           > 	
           > 	*<span style="font-style:italic; color:#9a7db0">**JVM** sẽ monitor xem đoạn code nào được thực thi nhiều lần. Đoạn code đó có thể là method, một phần của method hoặc một vòng lặp (loop). Sau khi tìm được **block of code** đó, thay vì mỗi lần thực thi phải **interpret** sang **machine code** thì nó được **compile** sang **machine code** luôn cho nhanh. Tất nhiên sau khi **compile** phải có nơi lưu trữ lại **native code** đó, là **code cache**.</span>*
           > 	<span style="color:#9a7db0">➡️ Như vậy, tại một thời điểm, một vài phần của chương trình sẽ không chạy trong trạng thái **interpretive** nữa mà là thực thi luôn **native code**.</span>
           > 	*<span style="font-style:italic; color:#9a7db0">Việc **interpret** từ **bytecode** sang **native code** hay quyết định **compile** và lưu trữ lại **native code** đó hay không là nhiệm vụ của **Just-in-time Compiler**, ngắn gọn hơn là **JIT Compiler**.</span>*	
		
			<span style="color:#d4a216">==> While using a JIT compiler, the hardware is able to execute the native code  as opposed to having the JVM interpret the same sequence of bytecode repeatedly and incurring overhead for the translation process. JIT leads to performance gains in the execution speed, unless the compiled methods are executed less frequently.</span>
			<p style="text-align:center;">
		   <img src="https://media.geeksforgeeks.org/wp-content/uploads/java.jpg"/>
		   </p>

🍎 <span style="color:#00b050">**Reference:**</span> 
	- [WORA, JIT Compiler và -XX:+PrintCompilation](https://viblo.asia/p/001-wora-jit-compiler-va-xxprintcompilation-gDVK2O3nZLj)
	- [Compilation and Execution of a Java Program](https://www.geeksforgeeks.org/compilation-execution-java-program/)
	- [How JVM Works – JVM Architecture?](https://www.geeksforgeeks.org/jvm-works-jvm-architecture/)
> [!SUMMARIZE]- Summary
> file java -- sang javac -- compile -> bytecode lưu trong file class (đây đc gọi là Bytecode nhưng ko hoàn chỉnh so với việc biên dịch file C compile trực tiếp ra Assembly Lang) - chạy với máy ảo JAVA - JVM (JVM work with multiple OS platform) theo chỉ thị của JRE
> ![](https://i.imgur.com/6RPDXCb.png)
> ![](https://i.imgur.com/rzRoNDW.png)
	

### 2. Khái niệm JDK, JRE, JVM
> - JVM là thành phần nền tảng Java thực thi các chương trình của bạn.
> - JRE khởi tạo JVM và đảm bảo các phụ thuộc có sẵn cho các chương trình của bạn.
> - JDK cho phép bạn tạo các chương trình Java có thể được thực thi và chạy bởi JVM và JRE.

![](https://i.imgur.com/vFf5XJp.png)
![](https://i.imgur.com/ZvOHqPA.png)


🍎 <span style="color:#00b050">**Reference:**</span>  
- [DIFFERENCES BETWEEN JDK, JRE AND JVM](https://prutor.ai/differences-between-jdk-jre-and-jvm/)
- [JVM, JRE và JDK](https://howkteam.vn/course/lap-trinh-java-co-ban-den-huong-doi-tuong/cai-dat-moi-truong-java-3834)
- [JRE in Java - GeeksforGeeks](https://www.geeksforgeeks.org/jre-in-java/)












